181860152 周宇翔L1 实验报告

1.框架
本实验的框架为
定义Block数据结构管理每一块分配出去的内存空间
用两条并发链表管理共享内存部分的分配和回收,空链表头分别为
free_head，alloc_head,其中free_head按照严格升序的方式链接每一个未分配的管理块，
而alloc_head中管理的已分配块之间可以随意链接。

我将把可用的内存空间[_heap.start,_heap.end)划分成为三块
[_heap.end-0x2000000,_heap.end)为专门用于存放Block结构的区域
Block结构的申请释放，我另外用balloc，bfree函数进行管理，由于Block结构大小确定
这一部分只需要用类似栈的方式往上垒就很好实现

[_heap.end-0x2000000-0x800000*_ncpu(),_heap.end-0x2000000)为slab的区域，我给
每个CPU分配0x2000000的大小空间用作它专用的slab空间

[_heap.start,_heap.end-0x2000000-0x800000*_ncpu())则是本实验用kfree和kalloc主要管理的内存区域

kalloc的实现思路为
开始时先调用slab_kalloc,slab_kalloc和kalloc的区别仅在于无锁且分配的内存范围不同.
如果slab_kalloc成功返回指针则直接返回.
否则从全局链表free_head中依次查找有无能分配该内存的区间

kfree则是先从当前CPU对应的slab中去找有无对应的区块，如果没有再到alloc_head所管理的共享
内存中去找，如果找到了则将该Block从alloc_head中删除,并插入到free_head中去
这里的链表insert设计了两种模式，一种是普通的插入，另一种是检测前后节点代表的区间是否相连，如果相连就直接合并，这很符合本实验的要求

并发部分用了三把大锁实现,因为fine-grained lock实在是过于难实现
glb_lock用于控制两条全局链表的分配
alloc_lock用于控制Block结构的分配释放
print_lock用于保证输出信息的完整性，实际可以不用用到

2.bug?
遇到的bug其实没有什么让人顿悟或者让人感觉醍醐灌顶的那种，但是因为并发程序会无限放大一个小错误，然后又极其难调试，有时你很难发现到底是程序的本身写错了还是并发部分写的不够好，所以很容易就是数组越界之类的错误让人十分困扰(谁能想到我被这个困扰了半天呢).但是由并发本身导致的错误倒是没有那么地难调，比如AA型死锁，基本上把程序逻辑理一理，多打几个断点就看出来了.(当然我这么说可能是因为我就完全没有感觉到现在程序中有哪些埋得很深的错误)

3.测试
提交后Hard Test过了一个，但是好像是最复杂的那个，就很奇怪...在本地上设计了四种workloads，分别是完全随机，大小交替，超频繁小，频繁大，同时写了两个函数用于检查全局链表alloc_head和free_head的合法性，每次分配释放后都会进行检查，也没有出现什么问题，这样就就感觉debug无从下手了，所以就只能这样了.如果还有问题应该会在之后的试验中暴露出来

--------------------------------------

181860152 周宇翔L2　实验报告
L2最好的提交结果是只fail了一个hard test,但是后面修改代码之后又都过不了了，所以还是以那个版本为准吧...暂时先提交一个实验报告.另外，之前提交的L1报告文件名打成18186015.pdf了，如果没有找到实验报告可以找下这个文件名.

对于L2的感想:
1.L2的代码量比L1小很多，但是理解上的难度要多很多





