181860152 周宇翔L1 实验报告

1.框架
本实验的框架为
定义Block数据结构管理每一块分配出去的内存空间
用两条并发链表管理共享内存部分的分配和回收,空链表头分别为
free_head，alloc_head,其中free_head按照严格升序的方式链接每一个未分配的管理块，
而alloc_head中管理的已分配块之间可以随意链接。

我将把可用的内存空间[_heap.start,_heap.end)划分成为三块
[_heap.end-0x2000000,_heap.end)为专门用于存放Block结构的区域
Block结构的申请释放，我另外用balloc，bfree函数进行管理，由于Block结构大小确定
这一部分只需要用类似栈的方式往上垒就很好实现

[_heap.end-0x2000000-0x800000*_ncpu(),_heap.end-0x2000000)为slab的区域，我给
每个CPU分配0x2000000的大小空间用作它专用的slab空间

[_heap.start,_heap.end-0x2000000-0x800000*_ncpu())则是本实验用kfree和kalloc主要管理的内存区域

kalloc的实现思路为
开始时先调用slab_kalloc,slab_kalloc和kalloc的区别仅在于无锁且分配的内存范围不同.
如果slab_kalloc成功返回指针则直接返回.
否则从全局链表free_head中依次查找有无能分配该内存的区间

kfree则是先从当前CPU对应的slab中去找有无对应的区块，如果没有再到alloc_head所管理的共享
内存中去找，如果找到了则将该Block从alloc_head中删除,并插入到free_head中去
这里的链表insert设计了两种模式，一种是普通的插入，另一种是检测前后节点代表的区间是否相连，如果相连就直接合并，这很符合本实验的要求

并发部分用了三把大锁实现,因为fine-grained lock实在是过于难实现
glb_lock用于控制两条全局链表的分配
alloc_lock用于控制Block结构的分配释放
print_lock用于保证输出信息的完整性，实际可以不用用到

2.bug?
遇到的bug其实没有什么让人顿悟或者让人感觉醍醐灌顶的那种，但是因为并发程序会无限放大一个小错误，然后又极其难调试，有时你很难发现到底是程序的本身写错了还是并发部分写的不够好，所以很容易就是数组越界之类的错误让人十分困扰(谁能想到我被这个困扰了半天呢).但是由并发本身导致的错误倒是没有那么地难调，比如AA型死锁，基本上把程序逻辑理一理，多打几个断点就看出来了.(当然我这么说可能是因为我就完全没有感觉到现在程序中有哪些埋得很深的错误)

3.测试
提交后Hard Test过了一个，但是好像是最复杂的那个，就很奇怪...在本地上设计了四种workloads，分别是完全随机，大小交替，超频繁小，频繁大，同时写了两个函数用于检查全局链表alloc_head和free_head的合法性，每次分配释放后都会进行检查，也没有出现什么问题，这样就就感觉debug无从下手了，所以就只能这样了.如果还有问题应该会在之后的试验中暴露出来

--------------------------------------

181860152 周宇翔L2　实验报告
之前提交的L1报告文件名打成18186015.pdf了，如果没有找到实验报告可以找下这个文件名.

对于L2的感想:
1.L2的代码量比L1小很多，但是理解上的难度要稍微大一些,首先是kmt模块的实现,这一块还好,一方面中断机>制的实现可以通过阅读abstract machine中的cte.c来辅助理解,另一方面可以参考上学期的ics实现来做，只要做到合理地分配和设置就能完成.另外，由于之前M2中做协程管理的经验，这里管理线程也可以采用类似的方式
实现并套用API.
另一个则是信号量的实现，这个看起来原理挺简单，其实有挺多细节的，比如开中断和关中断的时机要把握好，哪一部分需要上锁也要斟酌。并且还要设计相应的数据结构来管理信号量的waiter,并提供唤醒waiter和使线程变为waiter的借口.还有一些不可名状的bug,比如在sem_wait的过程中current可能突然切换,但是这样的bug 还是可以比较粗暴地解决的

2.目前还没有实现避免starvation的调度器,因为个人已有的task实现和thread-os-mp中稍有出入,所以必须得稍微重构一些才能实现,等有时间再做

3.有一个bug不太能理解,就是为了让task被更公平地被调度,我用ct记录每一个task被调度的次数，如果在schedule函数里采用搜索并调度ct最小的task就会死锁,而随机调度则不会，尽管这一部分并没有上锁(也不太需要>上锁).我以为是在schedule里不能停留太久，于是尝试把排序的过程挪到schedule外面，在schedule内仍然以O(1)的时间找到被调度的线程,仍然不能解决，所以暂时放弃了这一想法.

4.L2-dev测试真的很难用，下下来光是能编译通过就要花好久.




